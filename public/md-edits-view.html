<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MD File Edits</title>
  <style>
    :root {
      --bg: #0d0f14;
      --surface: #141922;
      --border: #1e2530;
      --muted: #6b7a8f;
      --text: #e4e8ef;
      --accent: #5eb9ff;
      --font-mono: ui-monospace, "Cascadia Code", Menlo, Monaco, monospace;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }
    .container { max-width: 1200px; margin: 0 auto; padding: 2rem; }
    h1 { font-size: 1.5rem; margin: 0 0 0.5rem; }
    .subtitle { color: var(--muted); font-size: 0.9rem; margin-bottom: 1.5rem; }
    .controls { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
    .controls button {
      background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
      color: var(--accent); padding: 0.4rem 0.8rem; font-size: 0.85rem; cursor: pointer;
    }
    .controls button:hover { background: var(--border); }
    .loading { text-align: center; padding: 4rem; color: var(--muted); }
    #chart { width: 100%; min-height: 400px; overflow-x: auto; }
    .tooltip {
      position: absolute; visibility: hidden; background: var(--surface); border: 1px solid var(--border);
      border-radius: 8px; padding: 12px 16px; max-width: 400px; max-height: 300px; overflow-y: auto;
      font-size: 0.85rem; line-height: 1.5; z-index: 1000; pointer-events: none;
    }
    .tooltip .file { font-weight: 600; color: var(--accent); margin-bottom: 6px; }
    .tooltip .time { font-size: 0.75rem; color: var(--muted); margin-bottom: 6px; }
    .tooltip .summary { color: var(--text); }
    .tooltip .bytes { font-size: 0.75rem; color: var(--muted); margin-top: 4px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
</head>
<body>
  <div class="container">
    <h1>MD File Edits</h1>
    <p class="subtitle">SOUL.md, AGENTS.md, IDENTITY.md, USER.md, MEMORY.md, HEARTBEAT.md — dot size = bytes written</p>
    <div class="controls">
      <button type="button" id="btn-reset">Reset time window</button>
      <span id="range-label" style="color: var(--muted); font-size: 0.85rem;"></span>
    </div>
    <div id="chart"></div>
  </div>
  <div class="tooltip" id="tooltip"></div>
  <script>
    const TARGET_FILES = ["SOUL.md", "AGENTS.md", "IDENTITY.md", "USER.md", "MEMORY.md", "HEARTBEAT.md"];
    const ROWS_PER_FILE = 10;
    const DOT_SIZE_MIN = 4;
    const DOT_SIZE_MAX = 20;
    const OVERLAP_MS = 2000; // dots within 2 sec stack in different rows

    const FILE_COLORS = {
      "SOUL.md": "#5eb9ff",
      "AGENTS.md": "#a78bfa",
      "IDENTITY.md": "#34d399",
      "USER.md": "#f59e0b",
      "MEMORY.md": "#f472b6",
      "HEARTBEAT.md": "#22c55e",
    };

    let allEdits = [];
    let timeDomain = null;

    function assignSubRows(edits) {
      const byFile = d3.group(edits, d => d.category);
      const result = [];
      for (const [file, dots] of byFile) {
        const sorted = [...dots].sort((a, b) => a.time - b.time);
        const lastTimeByRow = Array(ROWS_PER_FILE).fill(-Infinity);
        for (const d of sorted) {
          const t = d.time.getTime();
          let row = 0;
          for (; row < ROWS_PER_FILE; row++) {
            if (t - lastTimeByRow[row] >= OVERLAP_MS) break;
          }
          row = Math.min(row, ROWS_PER_FILE - 1);
          lastTimeByRow[row] = t;
          result.push({ ...d, subRow: row, laneId: `${file}::${row}` });
        }
      }
      return result;
    }

    async function loadData() {
      document.getElementById("chart").innerHTML = '<div class="loading">Loading events…</div>';
      const res = await fetch("/events-slim.json");
      const data = await res.json();
      const events = data.events || [];
      allEdits = events
        .filter(e => e.type === "md_write" && TARGET_FILES.includes(e.category))
        .map(e => ({
          ...e,
          time: new Date(e.time),
          bytes: e.bytes ?? (e.message ? e.message.length : 0),
        }))
        .sort((a, b) => a.time - b.time);
      if (allEdits.length === 0) {
        document.getElementById("chart").innerHTML = '<div class="loading">No MD edits found for target files.</div>';
        return;
      }
      timeDomain = [allEdits[0].time, allEdits[allEdits.length - 1].time];
      render();
    }

    function render() {
      const chartEl = document.getElementById("chart");
      chartEl.innerHTML = "";
      const width = Math.max(800, chartEl.clientWidth || 800);
      const height = 500;
      const margin = { top: 20, right: 20, bottom: 60, left: 110 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      const brushHeight = 36;

      const [start, end] = timeDomain;
      const filtered = allEdits.filter(e => e.time >= start && e.time <= end);
      const withSubRows = assignSubRows(filtered);

      const lanes = TARGET_FILES.flatMap(f => Array.from({ length: ROWS_PER_FILE }, (_, i) => `${f}::${i}`));
      const extent = d3.extent(withSubRows, d => d.bytes) || [0, 1000];
      const sizeScale = d3.scaleSqrt().domain(extent).range([DOT_SIZE_MIN, DOT_SIZE_MAX]);

      const svg = d3.select(chartEl)
        .append("svg")
        .attr("width", width)
        .attr("height", height + brushHeight)
        .attr("viewBox", `0 0 ${width} ${height + brushHeight}`);

      const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
      const brushG = svg.append("g").attr("transform", `translate(${margin.left},${height + 8})`);

      const xScale = d3.scaleTime()
        .domain([start, end])
        .range([0, innerWidth]);
      const yScale = d3.scaleBand()
        .domain(lanes)
        .range([0, innerHeight])
        .padding(0.05);

      const xAxis = d3.axisBottom(xScale).ticks(8).tickFormat(d3.timeFormat("%b %d %H:%M"));
      g.append("g").attr("transform", `translate(0,${innerHeight})`).call(xAxis).selectAll("text").attr("fill", "#6b7a8f").style("font-size", "10px");

      const yAxisG = g.append("g").call(d3.axisLeft(yScale).tickSize(0));
      yAxisG.selectAll("text").attr("fill", "#6b7a8f").style("font-size", "10px")
        .text(d => d.split("::")[1] === "0" ? d.split("::")[0] : "");

      const dots = g.selectAll("circle").data(withSubRows).join("circle")
        .attr("cx", d => xScale(d.time))
        .attr("cy", d => yScale(d.laneId) + yScale.bandwidth() / 2)
        .attr("r", d => sizeScale(d.bytes))
        .attr("fill", d => FILE_COLORS[d.category] ?? "#6b7a8f")
        .attr("fill-opacity", 0.85)
        .attr("stroke", "#0d0f14")
        .attr("stroke-width", 1)
        .style("cursor", "pointer");

      const tooltip = document.getElementById("tooltip");
      dots
        .on("mouseenter", (ev, d) => {
          tooltip.innerHTML = `
            <div class="file">${d.category}</div>
            <div class="time">${d3.timeFormat("%b %d %H:%M:%S")(d.time)}</div>
            <div class="summary">${(d.modSummary || d.summary || d.message || "").slice(0, 300)}${(d.modSummary || d.summary || d.message || "").length > 300 ? "…" : ""}</div>
            <div class="bytes">${d.bytes} bytes</div>
          `;
          tooltip.style.visibility = "visible";
        })
        .on("mousemove", (ev) => {
          tooltip.style.top = (ev.pageY + 12) + "px";
          tooltip.style.left = Math.min(ev.pageX + 12, window.innerWidth - 420) + "px";
        })
        .on("mouseleave", () => { tooltip.style.visibility = "hidden"; });

      // Brush for time window (flag prevents recursion: brush.move fires "end")
      const fullExtent = [allEdits[0].time, allEdits[allEdits.length - 1].time];
      const brushXScale = d3.scaleTime().domain(fullExtent).range([0, innerWidth]);
      let skipBrushEnd = false;
      const brush = d3.brushX().extent([[0, 0], [innerWidth, brushHeight]]).on("end", (ev) => {
        if (skipBrushEnd) {
          skipBrushEnd = false;
          return;
        }
        const sel = ev.selection;
        if (sel) {
          timeDomain = [brushXScale.invert(sel[0]), brushXScale.invert(sel[1])];
          render();
        }
      });
      brushG.call(brush);
      skipBrushEnd = true;
      brushG.call(brush.move, [brushXScale(start), brushXScale(end)]);
      brushG.selectAll(".selection").attr("stroke", "rgba(94,185,255,0.4)").attr("fill", "rgba(94,185,255,0.15)");

      document.getElementById("range-label").textContent =
        `${d3.timeFormat("%b %d")(start)} – ${d3.timeFormat("%b %d")(end)} (${filtered.length} edits)`;
    }

    document.getElementById("btn-reset").addEventListener("click", () => {
      if (allEdits.length) {
        timeDomain = [allEdits[0].time, allEdits[allEdits.length - 1].time];
        render();
      }
    });

    loadData().catch(e => {
      const msg = e.message || String(e);
      const hint = msg.includes("404") || msg.includes("fetch") ? "Run: npm run parse && npm run mods-then-slim" : msg;
      document.getElementById("chart").innerHTML = `<div class="loading">${hint}</div>`;
    });
  </script>
</body>
</html>
